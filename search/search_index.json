{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Getting Started","text":"<p>DB Operator is a Kubernetes operator for managing MySQL and PostgreSQL databases through CRDs.</p> <p>This operator doesn't launch database servers, instead it should be connected to the running ones, that's why it doesn't nececeraly require that the database is running in Kubernetes, and can be used with any server that can be accessed from inside the cluster.</p> <p>After it is connected to a server, you can start managing databases and users through CRDs. When a user or a database is created, db-operator will add a <code>Secret</code> and a <code>ConfigMap</code> to the namespace where CR is deployed, they can be used by a pod to establish a connection with a database.</p>"},{"location":"#example","title":"Example","text":"<p>Let's imagine, you have an application that requires a connection to a Postgres DB, it receives credentials from the environment variable <code>POSTGRES_DATASOURCE</code>, and it needs to be in a following format: <code>postgresql://${USER}:${PASSWORD}@${HOSTNAME}:${PORT}/${DATABASE}?search_path=myapp</code></p> <p>We will talk about how to install the operator and connect it to a server later, now let's focus on the main logic. We need to create a <code>Database</code> resource:</p> <pre><code>apiVersion: kinda.rocks/v1beta1\nkind: Database\nmetadata:\n  name: my-app\n  namespace: my-namespace\nspec:\n  backup:\n    enable: false\n  credentials:\n    templates:\n    # - This template will be used by the operator to add POSTGRES_DATASOURCE to the secret.\n    - name: POSTGRES_DATASOURCE\n      secret: true\n      template: '{{ .Protocol }}://{{ .Username }}:{{ .Password }}@{{ .Hostname }}:{{ .Port }}/{{ .Database }}?search_path=my-app'\n  deletionProtected: true\n  instance: some-postgres\n  postgres:\n    dropPublicSchema: true\n    schemas:\n    - my-app\n  secretName: my-app-db-creds\n</code></pre> <p>Read more about templates here</p> <p>(@allanger): This logic might be changed when the <code>Database</code> resource will be upgrade to the version <code>v1</code> After the reconciliation you should be able to find a <code>ConfigMap</code> and a <code>Secret</code> in the namespace <code>my-namespace</code>. They both will be called <code>my-app-db-creds</code>, and you can use them to connect your application to the database. No manual interactions are needed, everything is managed within a Kubernetes cluster.</p>"},{"location":"#install-db-operator","title":"Install db-operator","text":"<p>We distribute DB Operator as a <code>helm</code> chart. You don't have to use it, but if you want to be able to get support, it's would be easier for us if you use the chart.</p> <p>The charts are released as s simple helm repo as well as a an OCI artifact.</p> <p>To use the repo, run the following:</p> <pre><code>$ helm repo add db-operator https://db-operator.github.io/charts\n$ helm search repo db-operator\n</code></pre> <p>OCI artifacts are available under <code>ghcr.io/db-operator/charts/</code></p> <p>To install the chart, run the following:</p> <pre><code>$ helm install db-operator/db-operator\n# -- Or OCI\n$ helm install ghcr.io/db-operator/charts/db-operator:${CHART_VERSION}\n</code></pre> <p>More info about the db-operator chart can be found in the README.md</p>"},{"location":"#create-a-dbinstance","title":"Create a DbInstance","text":"<p>After the operator is installed, you need to connect it to a database. For this the <code>db-instances</code> chart can be used.</p> <p>Create a following <code>values.yaml</code> file:</p> <pre><code># -- values.yaml\ndbinstances:\n  instance1:\n    engine: postgres\n    monitoring:\n      enabled: false\n    secrets:\n      adminUser: admin # Root username\n      adminPassword: password # Root password\n    generic:\n      host: postgres.databases.svc.cluster.local # Host\n      port: 5432\n</code></pre> <p>And install a helm chart like this:</p> <pre><code>$ helm install db-operator/db-instances -f ./values.yaml\n</code></pre> <p>To check the DbInstance status, run:</p> <pre><code>kubectl get dbinstance instance1\n\nNAME              PHASE          STATUS\ninstance1         Running        true\n</code></pre> <p>If <code>.status.Status</code> is <code>true</code>, it means that you can create Databases on this instance.</p> <p>You can read more about DbInstances here</p>"},{"location":"#create-a-database","title":"Create a Database","text":"<p>After the instancei is ready, you can start managing databases with the operator. Databases are not packaged in any helm chart, because they are supposed to be parts of the end applications, like an <code>Ingress</code> or a <code>PVC</code>, - something that your pod will need to run. Let's create a database:</p> <pre><code># - db.yaml\napiVersion: kinda.rocks/v1beta1\nkind: Database\nmetadata:\n  name: database-1\nspec:\n  backup:\n    enable: false\n  deletionProtected: false\n  instance: instance1\n  secretName: database-1-creds\n</code></pre> <pre><code>$ kubectl apply -f db.yaml\n$ kubectl get db\nNAME         STATUS   PROTECTED   DBINSTANCE         OPERATORVERSION   AGE\ndatabase-1   true     false       instance1          2.19.0            31s\n</code></pre> <p>When <code>.status.Status</code> is <code>true</code>, it means that you can use your database.</p> <p>You can read more about databases here</p>"},{"location":"#faq","title":"F.A.Q.","text":""},{"location":"#how-to-add-ownerreferences-to-secrets-and-configmaps-created-by-the-operator","title":"How to add ownerReferences to Secrets and ConfigMaps created by the operator?","text":"<p>DB Operator is designed in a way, that an application should be able to connect to a database, even if the operator was accidentally removed with all the CRDs. That's why by default Secrets and ConfigMaps are just created in the cluster without owner references. But if you would like these resources to be cleaned up after a databases is removed, or you need to see connection between them in ArgoCD, you can set the <code>.spec.cleanup</code> to <code>true</code></p> <p>If ArgoCD is used to manage Databases and the <code>cleanup</code> is set to <code>true</code>, please make sure that the <code>PrunePropagationPolicy</code> is not set to <code>foreground</code>, because db-operator is using secrets to understand which Database must be removed, and with the <code>foreground</code> policy the secret is removed before the Database, that makes it impossible for the operator to finish the reconciliation.</p>"},{"location":"#how-to-connect-the-operator-to-an-existing-database","title":"How to connect the operator to an existing Database?","text":"<p>DB Operator is reading the secret using the <code>spec.secretName</code> entry. If this secret doesn't exist, operator will create it and read data out of it. But if a secret is found, it will try to get items that are required to connect to a database from there.</p> <p>There are the keys, they a secret must contain:</p> <pre><code># for PosrgreSQL\nPOSTGRES_DB: $DATABASE_NAME\nPOSTGRES_PASSWORD: $PASSWORD\nPOSTGRES_USER: $USERNAME\n# and for MySQL\nDB: $DATABASE_NAME\nPASSWORD: $PASSWORD\nUSER: $USER\n</code></pre>"},{"location":"#how-to-rotate-passwords","title":"How to rotate passwords?","text":"<p>To rotate a db password with a help of DB Operator, it's enough to remove/update the secret that is used by a database.</p>"},{"location":"database/","title":"Database","text":"<p>Database might be considered the most important resource in the operator. It should be used to manage the lifecycle of databases and a users associated with them on the server.</p>"},{"location":"database/#how-to-create-and-use-a-database","title":"How to create and use a database","text":"<p>To create a <code>Database</code>, you first would need to have a running <code>DbInstance</code>. You can read about the <code>DbInstances</code> here.</p> <p>After you have a working <code>DbInstance</code> you can start creating a database.</p> <p>Let's start by defining an instance on which the database should be deployed. Let's assume you have an instance called <code>cloudnative-pg</code></p> <pre><code>apiVersion: kinda.rocks/v1beta1\nkind: Database\nmetadata:\n  name: my-database\nspec:\n  instance: cloudnative-pg\n</code></pre> <p>Then we need to define a name that is going to be used by the operator to create a <code>ConfigMap</code> and a <code>Secret</code>. If a secret with this name already exists, db-operator will try to use it, but let's talk about it later.</p> <pre><code>apiVersion: kinda.rocks/v1beta1\nkind: Database\nmetadata:\n  name: my-database\nspec:\n    instance: cloudnative-pg\n    secretName: my-database-creds\n</code></pre> <p>And this is already enough to start using a database, after applying this manifest, operator will create a database and a user on a server, assign required permissions, and create a Secret and a ConfigMap in Kubernetes. Let's check</p> <pre><code>$ kubectl get db my-database\nNAME          STATUS   PROTECTED   DBINSTANCE         OPERATORVERSION       AGE\nmy-database   true     false       cloudnative-pg   2.19.0                3m33s\n\n$ kubectl get secret my-database-creds\nNAME                TYPE     DATA   AGE\nmy-database-creds   Opaque   4      4m44s\n\n$ kubectl get cm my-database-creds\nNAME                DATA   AGE\nmy-database-creds   4      4m46s\n</code></pre> <p>The Secret should contain credentials to connect to the database generated by operator.</p> <p>For PostgreSQL:</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  labels:\n    app.kubernetes.io/managed-by: db-operator\n    kinda.rocks/used-by-kind: Database\n    kinda.rocks/used-by-name: my-database\n  name: my-database-creds\ntype: Opaque\ndata:\n  POSTGRES_DB: &lt;&lt; base64 encoded database name (generated by db operator) &gt;&gt;\n  POSTGRES_PASSWORD: &lt;&lt; base64 encoded password (generated by db operator) &gt;&gt;\n  POSTGRES_USER: &lt;&lt; base64 encoded user name (generated by db operator) &gt;&gt;\n  CONNECTION_STRING: &lt;&lt; base64 encoded database connection string &gt;&gt;\n</code></pre> <p>For MySQL:</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  labels:\n    app.kubernetes.io/managed-by: db-operator\n    kinda.rocks/used-by-kind: Database\n    kinda.rocks/used-by-name: my-database\n  name: my-database-creds\ntype: Opaque\ndata:\n  DB: &lt;&lt; base64 encoded database name (generated by db operator) &gt;&gt;\n  PASSWORD: &lt;&lt; base64 encoded password (generated by db operator) &gt;&gt;\n  USER: &lt;&lt; base64 encoded user name (generated by db operator) &gt;&gt;\n  CONNECTION_STRING: &lt;&lt; base64 encoded database connection string &gt;&gt;\n</code></pre> <p>And the ConfigMap should contain connection information for database server access.</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  labels:\n    app.kubernetes.io/managed-by: db-operator\n    kinda.rocks/used-by-kind: Database\n    kinda.rocks/used-by-name: my-database\n  name: my-database-creds\ndata:\n  DB_CONN: &lt;&lt; database server address &gt;&gt;\n  DB_PORT: &lt;&lt; database server port &gt;&gt;\n  DB_PUBLIC_IP: &lt;&lt; database server public ip &gt;&gt;\n  ...\n</code></pre> <p>By default, ConfigMap and Secret are created without owner references, so they won't be removed once the <code>Database</code> resource is removed. If you want them to be deleted too, you need to turn on the cleanup feature.</p> <pre><code>apiVersion: \"kinda.rocks/v1beta1\"\nkind: \"Database\"\nmetadata:\n  name: \"example-db\"\nspec:\n  cleanup: true\n</code></pre> <p>If ArgoCD is used to manage Databases and the <code>cleanup</code> is set to <code>true</code>, please make sure that the <code>PrunePropagationPolicy</code> is not set to <code>foreground</code>, because db-operator is using secrets to understand which Database must be removed, and with the <code>foreground</code> policy the secret is removed before the Database, that makes it impossible for the operator to finish the reconciliation.</p> <p>If this feature is enabled, then <code>Database</code> becomes an owner of Secrets and ConfigMaps, and by removing a database, you'll also remove them.</p> <p>With the Secret and the ConfigMap, we can connect to the database. Let's create a PostgreSQL Pod to test the connection.</p> <pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  name: my-app\nspec:\n  containers:\n  - name: postgres-create-table\n    image: postgres\n    command:\n      - psql\n    args:\n      - -c\n      - \"CREATE TABLE array_int (vector  int[][]);\"\n    env:\n      - name: PGPASSWORD\n        valueFrom:\n          secretKeyRef:\n            name: my-database-creds\n            key: POSTGRES_PASSWORD\n      - name: PGUSER\n        valueFrom:\n          secretKeyRef:\n            name: my-database-creds\n            key: POSTGRES_USER\n      - name: PGDATABASE\n        valueFrom:\n          secretKeyRef:\n            name: my-database-creds\n            key: POSTGRES_DB\n      - name: PGHOST\n        valueFrom:\n          configMapKeyRef:\n            name: my-database-creds\n            key: DB_CONN\n    imagePullPolicy: IfNotPresent\n  restartPolicy: Never\n</code></pre>"},{"location":"database/#generic-additional-options","title":"Generic additional options","text":""},{"location":"database/#deletion-protection","title":"Deletion Protection","text":"<p>For production databases you might want to set <code>.spec.deletionProtected</code> to <code>true</code>. With this setting, db-operator will not remove the database from the server, if a Kubernetes resource is deleted.</p>"},{"location":"database/#credentials-templates","title":"Credentials Templates","text":"<p>DB operator is capable of generating custom connections strings using the information it has about a database, here you can read more about templates.</p>"},{"location":"database/#extra-grants","title":"Extra Grants","text":"<p>It is possible to apply extra grants to databases, when it's enabled on the db-instance level. To enable it, one must set <code>.spec.allowExtraGrants</code> to <code>true</code> on an instance.</p> <p>We have two types of access defined in the code:     - readOnly     - readWrite</p> <p>It reflects the <code>DbUser</code> types of access.</p> <p>The idea behind the extra grants is that there might be a database user that must have access to certain databases, that is not necessarily managed by the operator. Let's say the user is called <code>database-admin</code>.</p> <p>Now for whatever reason, we want to let the admin access a database with readOnly permissions. In the db definition we need to add the following:</p> <pre><code>kind: Database\nspec:\n  extraGrants:\n    - user: database-admin\n      accessType: readOnly\n</code></pre> <p>Now the <code>database-admin</code> should have enough permissions for reading data from this database. If access needs to be revoked or changed to <code>readWrite</code>, it should be enough to remove the entry from the spec or modify it.</p>"},{"location":"database/#extra-labels-and-annotations","title":"Extra Labels and Annotations","text":"<p>With <code>credentials.metadata.extraLabels</code> and <code>credentials.metadata.extraAnnotations</code> you can add custom metadata to the Secret that stores the generated user credentials. These values are merged with the metadata created by the operator. Keys defined in <code>extraLabels</code> or <code>extraAnnotations</code> overwrite existing values with the same key.</p> <p>Example:</p> <pre><code>spec:\n  credentials:\n    metadata:\n      extraLabels:\n        environment: development\n      extraAnnotations:\n        reflector.v1.k8s.emberstack.com/reflection-allowed: \"true\"\n        reflector.v1.k8s.emberstack.com/reflection-auto-enabled: \"true\"\n        reflector.v1.k8s.emberstack.com/reflection-auto-namespaces: target-namespace\n</code></pre> <p>This metadata can be used by external controllers that watch annotations or require specific labels to enable Secret synchronization or reflection across namespaces.</p>"},{"location":"database/#additional-postgresql-options","title":"Additional PostgreSQL options","text":"<p>PostgreSQL database can be additionally configured using the <code>.spec.postgres{}</code> section.</p> <p>It's possible to drop ensure that the public schema is dropped by setting <code>.spec.postgres.dropPublicSchema</code>, and you can also create additional schemas that will be granted to the database user, managed by the operator, to do so, set the <code>.spec.postgres.schemas[]</code></p> <pre><code>postgres:\n  dropPublicSchema: true # Do not set it, or set to false if you don't want to drop the public schema\n  schemas: # The user that's going to be created by db-operator, will be granted all privileges on these schemas\n    - schema_1\n    - schema_2\n</code></pre> <p>If you initialize a database with <code>dropPublicSchema: false</code> and then later change it to <code>true</code>, or add schemas with the <code>schemas</code> field and later try to remove them by updating the manifest, you may be unable to do that. Because <code>db-operator</code> won't use <code>DROP CASCADE</code> for removing schemas, and if there are objects depending on a schema, someone with admin access will have to remove these objects manually.</p> <p>There is a support for Postgres Database Templates. To create a database from template, you need to set <code>.spec.postgres.template</code>. It's referencing to a database on the Postgres server, but not to the k8s Database resource that is created by operator, so there is no validation on the db-operator side that a template exists.</p>"},{"location":"database/#reusing-an-existing-secret","title":"Reusing an existing secret","text":"<p>It's possible to connect DB Operator to an existing database. To do so you'll need to point the operator to an existing secret. It\u2019s important that the secret follows the format expected by the operator.</p> <p>For postgres:</p> <pre><code>POSTGRES_DB: &lt;&lt; base64 encoded database name (generated by db operator) &gt;&gt;\nPOSTGRES_PASSWORD: &lt;&lt; base64 encoded password (generated by db operator) &gt;&gt;\nPOSTGRES_USER: &lt;&lt; base64 encoded user name (generated by db operator) &gt;&gt;\n</code></pre> <p>For mysql:</p> <pre><code>DB: &lt;&lt; base64 encoded database name (generated by db operator) &gt;&gt;\nPASSWORD: &lt;&lt; base64 encoded password (generated by db operator) &gt;&gt;\nUSER: &lt;&lt; base64 encoded user name (generated by db operator) &gt;&gt;\n</code></pre> <p>Then DB Operator will connect to an existing database and set up a user for it.</p>"},{"location":"database/#experimental-features","title":"Experimental features","text":"<p>Experimental features are added via annotations, the following features are available for <code>Databases</code></p>"},{"location":"database/#rds-iam-impersonate","title":"RDS IAM Impersonate","text":"<p>This annotation should be used, when a DbUser is not allowed to log in with password, should be used on the RDS instances, when the SSO is used for authentication.</p> <p>For more info see this issue: https://github.com/db-operator/db-operator/issues/125</p> <pre><code>kinda.rocks/rds-iam-impersonate: \"true\"\n</code></pre>"},{"location":"database/#force-database-deletion","title":"Force Database Deletion","text":"<p>Delete a postgres database with present connections, might be useful when pgbouncer is used</p> <pre><code>kinda.rocks/postgres-force-delete-db: \"true\"\n</code></pre>"},{"location":"database/#reconciliation-logic","title":"Reconciliation logic","text":"<p>By default db-operator checks if a database needs to be reconcilied.</p> <p>First, use can force a full reconciliation by setting a following annotation:</p> <pre><code>kinda.rocks/db-force-full-reconcile: \"true\"\n</code></pre> <p>If it's set, operator will remove it and run the full reconciliation.</p> <p>Then it checks if it's running in a mode, where it should not check changes and each resource should be fully reconcilied on each loop. Actually, by default it doesn't check and always reconciles databases, but to enable this mode, you need to run the operator with the <code>--check-for-changes</code> argument. It might be useful when you have a lot of databases, and updating each one of them might take a very long time.</p> <p>If you do check for changes, the operator will first check the status of a database and a secret that is used for creating a user. If the status is <code>false</code>, or the secret was changed, it will also trigger reconciliation.</p>"},{"location":"dbinstance/","title":"DbInstance","text":"<p>Currently, DbInstances are more or less a meta resource that connects the operator to a database server.</p> <p>There are actually two types of databases: generic and gsql, and the gsql one is supposed to bootstrap an sql instance in GCP, but they are going to be deprecated soon, and hence I don't feel like writing docs for them. The only important thing about them is that you shouldn't use them</p> <p>Here we only talk about the generic instances</p>"},{"location":"dbinstance/#how-to-configure-a-dbinstance","title":"How to configure a DbInstance","text":"<p>You need to have a PostgreSQL or a MySQL server running, and it has to be accessible by the operator. You also need a user with sufficient permissions, if it's fine in your environment, I would suggest to use an admin user.</p> <p>Now let's get started:</p> <pre><code>apiVersion: kinda.rocks/v1beta1\nkind: DbInstance\nmetadata:\n  name: cloudnative-pg\nspec:\n  adminSecretRef:\n    Name: cnpg17-admin-creds\n    Namespace: databases\n  # -- Legacy settings, please set it like this\n  # -- it's going to be removed in the next api version\n  backup:\n    bucket: \"\"\n  engine: postgres\n  generic:\n    hostFrom:\n      key: host\n      kind: ConfigMap\n      name: cloudnative-pg-config\n      namespace: databases\n    portFrom:\n      key: port\n      kind: ConfigMap\n      name: cloudnative-pg-config\n      namespace: databases\n  monitoring:\n    enabled: false\n</code></pre> <p>Let's quickly go through the yaml</p> <p>With <code>.adminSecretRef</code> you are pointing the operator to a secret, where the admin credentials are stored. They must be stored in a following format</p> <pre><code>kind: Secret\ndata:\n  # -- user might be omitted, then the following values will be used\n  # -- for PostgreSQL - postgres\n  # -- for MySQL      - root\n  user: &lt; base64 encoded admin username &gt;\n  password: &lt; base64 encoded admin password &gt;\n</code></pre> <p>With <code>.engine</code> you let the operator know, if it should treat a server as a PostgreSQL or a MySQL one. Possible values are <code>postgres</code> and <code>mysql</code></p> <p>Then you need to configure a URL and a port that the operator should try to connect to, there are two options to do that, you can set them directly in the manifest:</p> <pre><code>spec:\n  generic:\n    host: ${HOST}\n    port: ${PORT}\n</code></pre> <p>Or you can read them from a ConfigMap or a Secret:</p> <pre><code>spec:\n  generic\n    hostFrom:\n      key: host\n      kind: ConfigMap\n      name: cloudnative-pg-config\n      namespace: databases\n    portFrom:\n      key: port\n      kind: ConfigMap\n      name: cloudnative-pg-config\n      namespace: databases\n</code></pre>"},{"location":"dbinstance/#additional-configurations","title":"Additional configurations","text":""},{"location":"dbinstance/#extra-grants","title":"Extra Grants","text":"<p>To use the <code>.extraGrants</code> feature of <code>Databases</code>, you need to enabled it on the instance level. To do so, set the <code>.spec.allowExtraGrants</code> to <code>true</code></p>"},{"location":"dbinstance/#allowed-privileges","title":"Allowed Privileges","text":"<p>To use the <code>.extraPrivileges</code> feature of <code>DbUsers</code>, you also need to enabled the privileges on the instance level. Extra privileges is a list of roles that can be granteed to <code>DbUsers</code>. For example:</p> <pre><code>spec:\n  generic:\n    allowedPriveleges:\n      - readOnlyAdmin\n      - rds-iam\n</code></pre> <p>Then you will be able to assigned these roles to DbUsers. The roles are not managed by the operator, they must be already on a server when a user is created.</p>"},{"location":"dbinstance/#instance-vars","title":"Instance Vars","text":"<p>It may happen that you need to share the same variable in the Database/DbUser templates. Let's say you have a RW and RO urls, and your application need two env variables to connect: one - for actibely writing, and another - only for reading.</p> <p>The RW URL will be available anyway, but how to set a RO one.</p> <p>Without the instance vars you could just create a template with a hardcoded string in it:</p> <pre><code>templates:\n  - name: PG_READONLYHOST\n    secret: false\n    template: \"my-read-only-postgres-url.test\"\n</code></pre> <p>Or you can use the instance variables.</p> <pre><code>kind: DbInstance\nspec:\n  instanceVars:\n    PG_READONLYHOST: my-read-only-postgres-url.test\n</code></pre> <p>And then later use it in a template like that:</p> <pre><code>templates:\n  - name: PG_READONLYHOST\n    secret: false\n    template: '{{ .instanceVar \"PG_READONLYHOST\" }}'\n</code></pre> <p>If a value of a variable is changed on the instance, it will be also synced for each Database and User.</p>"},{"location":"dbuser/","title":"DbUser","text":"<p>DbUsers can be used to manage users on a database server.</p> <p>When you create a <code>Database</code>, db-operator will create a main user, that full access to the created database. You should use this user for you workloads. If you happen to need more users on your database, you can use <code>DbUser</code> Custom Resource</p>"},{"location":"dbuser/#how-to-create-dbusers","title":"How to create DbUsers","text":"<p>Let's have a look at the manifest:</p> <pre><code>apiVersion: kinda.rocks/v1beta1\nkind: DbUser\nmetadata:\n  name: mysql-readwrite\n  namespace: default\nspec:\n  secretName: mysql-readwrite-secret\n  accessType: readWrite\n  databaseRef: mysql-db\n</code></pre>"},{"location":"dbuser/#secret-name","title":"Secret Name","text":"<p>The <code>.secretName</code> we have already seen in the Databases, and here it's used almost in the same way. The only difference is that dbuser controller will reuse the ConfigMap that was created by the database controller, and will only create a Secret.</p>"},{"location":"dbuser/#access-types","title":"Access Types","text":"<p><code>DbUser</code> supports two access types:</p> <ul> <li>readWrite (SELECT, INSERT, UPDATE, DELETE)</li> <li>readOnly (SELECT)</li> </ul>"},{"location":"dbuser/#database-reference","title":"Database Reference","text":"<p>DbUsers are always attached to Databases. Once you have a Database that is ready, you can create a DbUser to grant additional access to it. Another important thing to consider, is that DbUser is a namespace resource, and it must live in the same namespace as a Database</p>"},{"location":"dbuser/#credentials-templates","title":"Credentials Templates","text":"<p>You can also use templates to generate connection strings for users, but since it's reusing the database ConfigMaps, you are only allowed to write templated values to Secrets, so the <code>.secret</code> in the template should always be <code>true</code></p>"},{"location":"dbuser/#extra-labels-and-annotations","title":"Extra Labels and Annotations","text":"<p>With <code>credentials.metadata.extraLabels</code> and <code>credentials.metadata.extraAnnotations</code> you can add custom metadata to the Secret that stores the generated user credentials. These values are merged with the metadata created by the operator. Keys defined in <code>extraLabels</code> or <code>extraAnnotations</code> overwrite existing values with the same key.</p> <p>Example:</p> <pre><code>spec:\n  credentials:\n    metadata:\n      extraLabels:\n        environment: development\n      extraAnnotations:\n        reflector.v1.k8s.emberstack.com/reflection-allowed: \"true\"\n        reflector.v1.k8s.emberstack.com/reflection-auto-enabled: \"true\"\n        reflector.v1.k8s.emberstack.com/reflection-auto-namespaces: target-namespace\n</code></pre> <p>This metadata can be used by external controllers that watch annotations or require specific labels to enable Secret synchronization or reflection across namespaces.</p>"},{"location":"dbuser/#experimental-features","title":"Experimental features","text":"<p>Experimental features are added via annotations, the following features are available for <code>DbUsers</code></p>"},{"location":"dbuser/#grant-to-admin-on-delete","title":"Grant To Admin on Delete","text":"<p>On instances where the admin is not a super user, it might not be able to drop owned by user, so we need to grant the user to the admin.</p> <p>But it's not possible on the AWS instances with the <code>rds_iam</code> roles, because then admins are not able to log in with a password anymore and the db-operator will not be able to do anything on databases.</p> <p>That's where this workaround might be used. It will only grant the role to the admin when a user is being removed.</p> <pre><code>kinda.rocks/grant-to-admin-on-delete: \"true\"\n</code></pre>"},{"location":"dbuser/#allow-existing-user","title":"Allow Existing User","text":"<p>By default the operator is trying to make sure, that the user that it's trying to maintain is also created by it. Because otherwise it would be possible to make operator believe that a Database user that is created by the database controller should become a readOnly one.</p> <p>So if a user already exists on a server, when a CR is created, operator will not try to manage it.</p> <p>If you need the operator to be able to managed existing users, you need to set the following annotation:</p> <pre><code>kinda.rocks/allow-existing-user: \"true\"\n</code></pre>"},{"location":"install_helm/","title":"Install with Helm","text":""},{"location":"install_helm/#getting-started","title":"Getting started","text":"<p>The only officially supported way to install DB Operator is using a helm chart.</p> <p>You can find the source code of our helm charts here: https://github.com/db-operator/charts</p> <p>The charts are released as s simple helm repo as well as a an OCI artifact.</p> <p>To install the repo, run the following</p> <pre><code>$ helm repo add db-operator https://db-operator.github.io/charts\n$ helm search repo db-operator\n</code></pre> <p>OCI artifacts are available under <code>ghcr.io/db-operator/charts/</code></p> <p>To install the chart, run the following:</p> <pre><code>$ helm install db-operator/db-operator\n# -- Or OCI\n$ helm install ghcr.io/db-operator/charts/db-operator:${CHART_VERSION}\n</code></pre> <p>More info about the db-operator chart can be found in the README.md</p>"},{"location":"install_helm/#configure-the-operator-via-values","title":"Configure the operator via values","text":"<p>@allanger chart will be updated soon, and then I'll write a better docs</p>"},{"location":"templates/","title":"Templates","text":"<p>DB Operator is capable of producing custom templated entries in <code>Secrets</code> and <code>ConfigMaps</code> using the database data. This features is using go templates and can be used in a following way:</p> <pre><code>---\n# in Databases\nkind: Database\nspec:\n  credentials:\n    templates:\n      - name: USER_AND_PASSWORD\n        template: \"{{ .Username }}-{{ .Password }}\"\n        secret: true\n---\n# or in DbUsers\nkind: DbUser\nspec:\n  credentials:\n    templates:\n      - name: USER_AND_PASSWORD\n        template: \"{{ .Username }}-{{ .Password }}\"\n        secret: true\n</code></pre>"},{"location":"templates/#available-fields-and-functions","title":"Available fields and functions","text":"<p>These fields are available for templating:</p> <ul> <li>Protocol: Depends on the db engine. Possible values are <code>mysql</code>/<code>postgresql</code></li> <li>Hostname: The same value as for db host in the connection configmap</li> <li>Port: The same value as for db port in the connection configmap</li> <li>Database: The same value as for db name in the creds secret</li> <li>Username: The same value as for database user in the creds secret</li> <li>Password: The same value as for password in the creds secret</li> </ul> <p>So to create a full connection string, you could use a template like that:</p> <pre><code>\"{{ .Protocol }}://{{ .Username }}:{{ .Password }}@{{ .Hostname }}:{{ .Port }}/{{ .Database }}\"\n</code></pre> <p>It's also possible to use one of these functions to get data directly from data sources available to the operator:</p> <ul> <li>Secret: Query data from the Secret</li> <li>ConfigMap: Query data from the ConfigMap</li> <li>Query: Get data directly from the database</li> </ul> <p>When using <code>Secret</code> and <code>ConfigMap</code> you can query the previously created secret to template a new one, e.g.:</p> <pre><code>spec:\n  credentials:\n    templates:\n      - name: TMPL_1\n        template: \"test\"\n        secret: false\n      - name: TMPL_2\n        template: \"{{ .ConfigMap \\\"TMPL_1\\\"}}\"\n        secret: true\n      - name: TMPL_3\n        template: \"{{ .Secret \\\"TMPL_2\\\"}}\"\n        secret: false\n</code></pre> <p>When using <code>Query</code> you need to make sure that you query returns only one value. For example:</p> <pre><code>...\n    templates:\n      - name: POSTGRES_VERSION\n        secret: false\n        template: \"{{ .Query \\\"SHOW server_version;\\\" }}\"\n</code></pre> <p>For values that are shared between different databases on the same instance, it's possible to set instance variables. Once they are set on the instance, they can also be used in database/dbuser templates.</p> <pre><code>kind: DbInstance\nspec:\n  instanceVars:\n    TEST_KEY: TEST_VALUE\n</code></pre> <p>These variables can be also accessed by the Database/DbUser templates</p> <pre><code>...\n    templates:\n      - name: DB_INSTANCE_VAR\n        secret: false\n        template: \"{{ .InstanceVar 'TEST_KEY' }}\"\n...\n</code></pre> <p>Then the secret that is created by the operator should contain the following entry: <code>DB_INSTANCE_VAR: TEST_VALUE</code>. When the value is changed on the instance level, it should also trigger reconciliation of the databases and hence the values should also be updated in the target secrets.</p>"},{"location":"development/contribution/","title":"How to contribute","text":""},{"location":"development/contribution/#workflow","title":"Workflow","text":""},{"location":"development/contribution/#how-to-become-a-maintainer","title":"How to become a maintainer","text":""},{"location":"development/helm-charts/","title":"Helm Chart development","text":"<p>The repository where the helm charts are being developed can be found here: https://github.com/db-operator/charts</p>"},{"location":"development/helm-charts/#tools","title":"Tools","text":"<p>Tools that are used for development:</p> <ul> <li>helm: https://helm.sh</li> <li>helmfile (used for testing): https://helmfile.readthedocs.io/en/latest/</li> <li>helm-unittest: https://github.com/helm-unittest/helm-unittest</li> <li>chart-testing: https://github.com/helm/chart-testing</li> <li>helm-docs: https://github.com/norwoodj/helm-docs</li> <li>pre-commit: https://pre-commit.com</li> </ul>"},{"location":"development/helm-charts/#crd-management","title":"CRD management","text":"<p>In our case it seemed like a good idea to install CRDs using the helm templates, as the db-operator chart itself doesn't depend on them. In order not to maintain them by hands, we've written a script <code>./scripts/sync_crds.sh</code>, that is getting a desired version from the db-operator's <code>Chart.yaml</code> and syncs CRDs from the operator repository.</p> <p>Let's say you have changed something in CRDs and want to test your change with the helm chart before the change is merged in the operator repository.</p> <pre><code>yq -i '.appVersion = \"${GIT_SHA}\"' ./charts/db-operator/Chart.yaml\n./scripts/sync_crds.sh\n</code></pre> <p>After that, CRDs will be up-to-date with the operator repo and you can test your changes.</p>"}]}